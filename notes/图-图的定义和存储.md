# 图的定义和存储

[TOC]

## 图的定义
图是由定点（Vertex）和边（Edge）组成，每条边的两端都必须是图的两个顶点（可以是相同的顶点）。用 `G（V，E）`表示图G的顶点集为 V，边集为 E。	

一般来说，图可以分为**有向图**和**无向图**。有向图的所有边都有方向，即确定了顶点到顶点的一个指向；而无向图的所有边都是双向的，即无向边所连接的两个顶点可以互相到达。


顶点的度是指和该顶点相连的边的条数，特别是对于有向图来说，顶点的出边条数称为该顶点的出度，顶点的入边条数称为该顶点的入度。

顶点和边都可以有属性，而量化的属性称为权值，顶点的权值和边的权值分别称为点权和边权。

## 图的存储

### 邻接矩阵

设图`G（V，E）`的顶点标号为 0，1，2，...，N-1，那么可以令二维数组`G[N][N]` 的两维分别表示图的顶点标号，即如果`G[i][j]==1` ，则说明顶点 i 和顶点 j 之间有边，如果`G[i][j]==0`，说明 顶点 i 和顶点 j 之间无边，这个二维数组`G[N][N]` 称为邻接矩阵。

如果存在边权，可以让`G[i][j]` 存放边权，不存在的边可以设置为 0，-1或者是一个很大的数。

虽然邻接矩阵很好写，但是需要开一个二维数组，如果是稀疏图，空间利用率太低，因此只适用于顶点数目不大的图。

### 邻接表

设图`G(V,E)` 的顶点编号为 0，1，2，……，N-1，每个顶点都可能有若干条出边，如果把所有的出边放在一个列表中，那么N个顶点就会有N个列表。

这N个列表称为图G的**邻接表**，记为 `Adj[N]` ，其中 `Adj[N]`存放顶点 i 的所有出边组成的列表。

可以使用链表来实现邻接表，但是我们可以采用更为简单的方式来实现链表，使用变长数组`vector`来实现。

```cpp
// 	如果不存放边权，可以直接用 int 来存储
vector<int> Adj[N];
// 如果添加一条从 1->3 的边
Adj[1].push_back(3);


//	如果存放边权，可以使用结构体 Node 来存放
struct Node{
	int v;	// 边终点编号
  int w;	// 边权
  Node(int _v, int _w): v(_v), w(_w) {} // 构造函数
};
// 添加一个从 1->4 ,边权为 5 的边
Adj[1].push_back(Node(4, 5));
```















