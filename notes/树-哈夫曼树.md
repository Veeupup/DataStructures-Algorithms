# 哈夫曼树 Huffman Tree
>在一个果园里，小明已经将所有的水果打了下来，并按水果的不同种类分成了若干堆，小明决定把所有的水果合成一堆。<br/>
>每一次合并，小明可以把两堆水果合并到一起，消耗的体力等于两堆水果的重量之和。<br/>
>当然经过 n‐1 次合并之后，就变成一堆了。小明在合并水果时总共消耗的体力等于每次合并所耗体力之和。     <br/>
>假定每个水果重量都为 1，并且已知水果的种类数和每种水果的数目，你的任务是设计出合并的次序方案，使小明耗费的体力最少，并输出这个最小的体力耗费值。<br/>
>例如有 3 种水果，数目依次为 1，2，9。可以先将 1，2 堆合并，新堆数目为3，耗费体力为 3。然后将新堆与原先的第三堆合并得到新的堆，耗费体力为 12。所以小明总共耗费体力=3+12=15，可以证明 15 为最小的体力耗费值。<br/>
>

以上就是搬水果问题，引入哈夫曼树。
> 树的带权路径长度 <br/>
> Weighted Path Length of Tree, WPL<br/>
> 等于它所有叶子结点的带权路径长度（叶子权值乘以路径长度）之和
已知 n 个数，寻找一个数，使得树的所有叶子结点的权值恰好为这 n 个数，并且这棵树的带圈路径长度最小。<br/>
带权路径长度最小的树被称为哈夫曼树，又被称为最优二叉树。<br/>
显然，对于同一组叶子结点来说，哈夫曼树可以是不唯一的，但是最小带权路径长度一定是唯一的。

## 构建哈夫曼树的算法
1. 初始状态下有 n 个结点（结点的权值分别是给定的n个数），将他们视作n棵只有一个结点的树
2. 合并其中根结点权值最小的两棵树，生成两棵树根结点的父节点，权值为这两个根结点的权值之和，这样树的数量就减少了一个
3. 重复操作 2，直到只剩下一棵树为止，这棵树就是哈夫曼树。
<br/>
思想：<br/>
反复选择两个最小的元素，合并，直到只剩下一个元素。一般可以使用优先队列（堆）来执行这种策略。

```cpp
int n;
    while (scanf("%d", &n) != EOF)
    {
        if (n == 0)
            break;
        // 小顶堆
        priority_queue<int, vector<int>, greater<int>> myPQ; 
        for (int i = 0; i < n; i++)
        {
            int x;
            scanf("%d", &x);
            myPQ.push(x);
        }
        int ans = 0;
        while (myPQ.size() > 1)
        {
            int a = myPQ.top();
            myPQ.pop();
            int b = myPQ.top();
            myPQ.pop();
            ans += a + b;
            myPQ.push(a + b);
        }
        printf("%d\n", ans);
    }
```



